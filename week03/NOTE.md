### 第三周学习笔记

#### 递归
1. 递归的本质是循环，是**通过函数体来进行的循环**。

2. **递归终止条件**：使用递归首先要考虑的是如何结束递归，否则会陷入死循环。

3. **回溯**：
	* 如果是在调用递归函数前改变了当前层的变量值，在调用完递归函数后，需要回溯（将变量的值恢复回去）。如果没有改变当前层的变量，则不需要回溯。
	* 比如下面的代码，used[i] 需要回溯，level 的值则不需要回溯。
	
	```C++
	...
	used[i] = true;
	dfs(level+1, used);
	used[i] = false;
	...
	```
	
4. 递归通常伴随着大量的重复计算，解决办法是缓存计算结果，做记忆化。

5. 递归栈的大小是有限制的，所以递归的深度不能太大，否则可能使递归栈爆掉。

6. 要相信递归能返回想要的结果，不要人肉递归去检查它，否则脑子会爆掉。

#### 分治
1. 分治中分的逻辑比较简单，直接递归调用解决各个子问题即可。主要的工作量在合并子问题的解上，如归并排序。

#### 组合与排列
1. **组合**：从数据源的角度考虑，1 - n 个数，每个数有选择和不选择两种情况。

2. **全排列**：从结果的角度考虑，1 到 k 个位置，每个位置从 1 - n 中选择一个数来填充。

3. **有重复元素的全排列**：与普通全排列的区别：
    * 先对数组排序，让相同的元素排在一起。
    * 排列过程中如果某个元素与前一个元素相同，且前一个元素没有在其它位置被使用，说明前一个元素在当前位置已经被尝试过了，当前元素与其相同，再尝试就重复了，需要跳过。

#### 二叉树最近公共祖先
1. 节点 root 是 p, q 最近公共祖先有两种情况：
 	* （1）root = p 或 q 并且另一个节点在 root 的左子树或右子树里
	* （2）p 和 q 分别在 root 的左右子树里
	* 需要用一个递归函数来判断 p 或 q 是否在这棵树里即可
